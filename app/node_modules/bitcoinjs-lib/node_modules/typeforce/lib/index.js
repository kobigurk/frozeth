'use strict';

function getFunctionName(fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
}

function getTypeTypeName(type) {
  if (nativeTypes.Function(type)) {
    type = type.toJSON ? type.toJSON() : getFunctionName(type);
  }
  if (nativeTypes.Object(type)) return JSON.stringify(type);

  return type;
}

function getValueTypeName(value) {
  if (nativeTypes.Null(value)) return '';

  return getFunctionName(value.constructor);
}

function tfErrorString(type, value) {
  var typeTypeName = getTypeTypeName(type);
  var valueTypeName = getValueTypeName(value);

  return 'Expected ' + typeTypeName + ', got ' + (valueTypeName && valueTypeName + ' ') + JSON.stringify(value);
}

function tfPropertyErrorString(type, name, value) {
  return tfErrorString('property \"' + name + '\" of type ' + getTypeTypeName(type), value);
}

var nativeTypes = {
  Array: (function (_Array) {
    function Array(_x) {
      return _Array.apply(this, arguments);
    }

    Array.toString = function () {
      return _Array.toString();
    };

    return Array;
  })(function (value) {
    return value !== null && value !== undefined && value.constructor === Array;
  }),
  Boolean: function Boolean(value) {
    return typeof value === 'boolean';
  },
  Buffer: (function (_Buffer) {
    function Buffer(_x2) {
      return _Buffer.apply(this, arguments);
    }

    Buffer.toString = function () {
      return _Buffer.toString();
    };

    return Buffer;
  })(function (value) {
    return Buffer.isBuffer(value);
  }),
  Function: function Function(value) {
    return typeof value === 'function';
  },
  Null: function Null(value) {
    return value === undefined || value === null;
  },
  Number: function Number(value) {
    return typeof value === 'number';
  },
  Object: function Object(value) {
    return typeof value === 'object';
  },
  String: function String(value) {
    return typeof value === 'string';
  },
  '': function _() {
    return true;
  }
};

function tJSON(type) {
  return type && type.toJSON ? type.toJSON() : type;
}

function sJSON(type) {
  var json = tJSON(type);
  return nativeTypes.Object(json) ? JSON.stringify(json) : json;
}

var otherTypes = {
  arrayOf: function arrayOf(type) {
    function arrayOf(value, strict) {
      try {
        return nativeTypes.Array(value) && value.every(function (x) {
          return typeforce(type, x, strict);
        });
      } catch (e) {
        return false;
      }
    }
    arrayOf.toJSON = function () {
      return [tJSON(type)];
    };

    return arrayOf;
  },

  maybe: function maybe(type) {
    function maybe(value, strict) {
      return nativeTypes.Null(value) || typeforce(type, value, strict);
    }
    maybe.toJSON = function () {
      return '?' + sJSON(type);
    };

    return maybe;
  },

  object: function object(type) {
    function object(value, strict) {
      typeforce(nativeTypes.Object, value, strict);

      var propertyName, propertyType, propertyValue;

      try {
        for (propertyName in type) {
          propertyType = type[propertyName];
          propertyValue = value[propertyName];

          typeforce(propertyType, propertyValue, strict);
        }
      } catch (e) {
        throw new TypeError(tfPropertyErrorString(propertyType, propertyName, propertyValue));
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue;

          throw new TypeError('Unexpected property "' + propertyName + '"');
        }
      }

      return true;
    }
    object.toJSON = function () {
      return type;
    };

    return object;
  },

  oneOf: function oneOf() {
    for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
      types[_key] = arguments[_key];
    }

    function oneOf(value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict);
        } catch (e) {
          return false;
        }
      });
    }
    oneOf.toJSON = function () {
      return types.map(sJSON).join('|');
    };

    return oneOf;
  },

  quacksLike: function quacksLike(type) {
    function quacksLike(value, strict) {
      return type === getValueTypeName(value);
    }
    quacksLike.toJSON = function () {
      return type;
    };

    return quacksLike;
  },

  tuple: function tuple() {
    for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }

    function tuple(value, strict) {
      return types.every(function (type, i) {
        return typeforce(type, value[i], strict);
      });
    }
    tuple.toJSON = function () {
      return '(' + types.map(sJSON).join(', ') + ')';
    };

    return tuple;
  },

  value: function value(expected) {
    function value(actual) {
      return actual === expected;
    }
    value.toJSON = function () {
      return expected;
    };

    return value;
  }
};

function compile(type) {
  if (nativeTypes.String(type)) {
    if (type[0] === '?') return otherTypes.maybe(compile(type.slice(1)));

    return nativeTypes[type] || otherTypes.quacksLike(type);
  } else if (type && nativeTypes.Object(type)) {
    if (nativeTypes.Array(type)) return otherTypes.arrayOf(compile(type[0]));

    var compiled = {};

    for (var propertyName in type) {
      compiled[propertyName] = compile(type[propertyName]);
    }

    return otherTypes.object(compiled);
  } else if (nativeTypes.Function(type)) {
    return type;
  }

  return otherTypes.value(type);
}

function typeforce(_x3, _x4, _x5) {
  var _again = true;

  _function: while (_again) {
    var type = _x3,
        value = _x4,
        strict = _x5;
    _again = false;

    if (nativeTypes.Function(type)) {
      if (type(value, strict)) return true;

      throw new TypeError(tfErrorString(type, value));
    }

    // JIT
    _x3 = compile(type);
    _x4 = value;
    _x5 = strict;
    _again = true;
    continue _function;
  }
}

// assign all types to typeforce function
var typeName;
Object.keys(nativeTypes).forEach(function (typeName) {
  var nativeType = nativeTypes[typeName];
  nativeType.toJSON = function () {
    return typeName;
  };

  typeforce[typeName] = nativeType;
});

for (typeName in otherTypes) {
  typeforce[typeName] = otherTypes[typeName];
}

module.exports = typeforce;
module.exports.compile = compile;